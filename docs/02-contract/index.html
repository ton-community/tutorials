<html>
  <head>
    <link rel="stylesheet" href="../assets/styles.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/github.min.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <!-- <script src="//cdn.jsdelivr.net/gh/highlightjs/highlightjs-func@0.1.1/dist/func.min.js"></script> -->
    <script src="../assets/func.min.js"></script> <!-- local version due to bug in Safari -->
    <script src="../assets/helpers.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon.png">
    <meta property="og:title" content="TON Hello World part 2: Step by step guide for writing your first smart contract">
    <title>TON Hello World part 2: Step by step guide for writing your first smart contract</title>
  </head>
  <body class="page">
    <div class="options" data-options="network,library" ></div>
    <nav>
      <a class="alogo" href="https://ton-community.github.io/tutorials">
        <div class="logo">
          <img src="../assets/logo.svg" />
          <p>Tutorials</p>
        </div>
      </a>
    </nav>
    <div style="display: flex;" class="main">
      <div class="rightcol">
        <div class="menu">
          <div class="selectboxes">
            
            <div class="selectbox" data-select="network">
              <h3 class="selectbox-title">Network</h3>
            <div class="selectbox-selected">
              <h3></h3>
              <img src = '../assets/arrow-down.svg' />
            </div>
            <ul class="options">
              
                <li data-value="testnet" class="option">
                <div class="option-name">
                  <h4>Testnet</h4>
                  <a href="https://ton.org/docs/develop/smart-contracts/environment/testnet">docs</a>
                </div>
                <div class="option-small">
                  <p class="pros">Pros: free to use</p>
                  <p class="cons">Cons: less reliable, requires special wallets</p>
                </div>
                </li>
              
                <li data-value="mainnet" class="option">
                <div class="option-name">
                  <h4>Mainnet</h4>
                  <a href="https://tonmon.xyz/?orgId=1&amp;refresh=5m">docs</a>
                </div>
                <div class="option-small">
                  <p class="pros">Pros: very reliable, fast, works with all wallets</p>
                  <p class="cons">Cons: not free to use (but very cheap)</p>
                </div>
                </li>
              
            </ul>
            </div>
          
            <div class="selectbox" data-select="library">
              <h3 class="selectbox-title">Library</h3>
            <div class="selectbox-selected">
              <h3></h3>
              <img src = '../assets/arrow-down.svg' />
            </div>
            <ul class="options">
              
                <li data-value="npmton" class="option">
                <div class="option-name">
                  <h4>npm ton (JavaScript)</h4>
                  <a href="https://github.com/ton-community/ton">docs</a>
                </div>
                <div class="option-small">
                  <p class="pros">Pros: more popular, full TypeScript support, elegant api</p>
                  <p class="cons">Cons: no support for all ton services</p>
                </div>
                </li>
              
            </ul>
            </div>
          
          </div>
          <div class="more">
            <h3>Tutorials</h3>
            <ul>
              <li><a data="tutorial-link" href="https://ton-community.github.io/tutorials/01-wallet">01. Working with your first wallet</a></li>
              <li><a data="tutorial-link" href="https://ton-community.github.io/tutorials/02-contract">02. Writing your first smart contract</a></li>
              <li><a data="tutorial-link" href="https://ton-community.github.io/tutorials/03-client">03. Building your first web client</a></li>
              <li><a data="tutorial-link" href="https://ton-community.github.io/tutorials/04-testing">04. Testing your first smart contract</a></li>
            </ul>
          </div>
          <div class="more">
            <h3>Help</h3>
            <ul>
              <li><a href="https://github.com/ton-community/tutorials/blob/main/HELP.md">Problems with this tutorial?</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="posts">
        
         <div class="post" data-combination="mainnet-npmton">
            <h1 id="tonhelloworldpart2stepbystepguideforwritingyourfirstsmartcontract">TON Hello World part 2: Step by step guide for writing your first smart contract</h1>
<div class="author">
  <img class="face" src="../assets/authors/talkol.jpg" />
  <span>by Tal Kol</span>
  <div>
    <a class="social" rel="noreferrer" href="https://t.me/talkol"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="FollowCard_icon__0yJs8" style="fill: currentcolor;"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM12.4298 8.85893C11.2626 9.3444 8.92989 10.3492 5.43165 11.8733C4.86359 12.0992 4.56601 12.3202 4.53892 12.5363C4.49314 12.9015 4.95047 13.0453 5.57323 13.2411C5.65794 13.2678 5.74571 13.2954 5.83569 13.3246C6.44839 13.5238 7.27258 13.7568 7.70104 13.766C8.0897 13.7744 8.52348 13.6142 9.0024 13.2853C12.2709 11.079 13.9581 9.96381 14.0641 9.93977C14.1388 9.92281 14.2424 9.90148 14.3125 9.96385C14.3827 10.0262 14.3758 10.1443 14.3684 10.176C14.3231 10.3691 12.5279 12.0381 11.5989 12.9018C11.3093 13.171 11.1038 13.362 11.0618 13.4056C10.9678 13.5034 10.8719 13.5958 10.7797 13.6846C10.2105 14.2333 9.78367 14.6448 10.8034 15.3168C11.2934 15.6397 11.6855 15.9067 12.0767 16.1731C12.5039 16.4641 12.93 16.7543 13.4814 17.1157C13.6218 17.2078 13.756 17.3034 13.8866 17.3965C14.3838 17.751 14.8305 18.0694 15.3823 18.0186C15.703 17.9891 16.0342 17.6876 16.2024 16.7884C16.6 14.6632 17.3814 10.0585 17.562 8.16098C17.5778 7.99473 17.5579 7.78197 17.5419 7.68857C17.5259 7.59518 17.4925 7.46211 17.3711 7.3636C17.2273 7.24694 17.0054 7.22234 16.9061 7.22408C16.4548 7.23203 15.7623 7.47282 12.4298 8.85893Z"></path></svg></a>
  <a class="social" rel="noreferrer" href="https://twitter.com/koltal"><svg viewBox="0 0 22 18" fill="none" xmlns="http://www.w3.org/2000/svg" class="FollowCard_icon__0yJs8" style="fill: currentcolor;"><path d="M19.7477 4.45029C19.7611 4.64423 19.7611 4.83818 19.7611 5.03391C19.7611 10.998 15.2208 17.8764 6.91863 17.8764V17.8728C4.46614 17.8764 2.06459 17.1739 0 15.8494C0.356612 15.8923 0.715011 15.9137 1.0743 15.9146C3.10672 15.9164 5.08105 15.2344 6.67999 13.9787C4.74857 13.9421 3.05489 12.6827 2.46321 10.8443C3.13979 10.9748 3.83693 10.9479 4.501 10.7665C2.39529 10.3411 0.880358 8.49099 0.880358 6.34238C0.880358 6.32272 0.880358 6.30395 0.880358 6.28518C1.50778 6.63464 2.21028 6.82859 2.92886 6.85004C0.945602 5.52459 0.334268 2.8862 1.53191 0.823391C3.82352 3.64322 7.20463 5.35746 10.8342 5.53889C10.4704 3.97123 10.9674 2.32849 12.14 1.22648C13.9579 -0.482398 16.8171 -0.394809 18.5259 1.42221C19.5368 1.2229 20.5056 0.851992 21.3922 0.326458C21.0553 1.37127 20.3501 2.25878 19.4081 2.82274C20.3027 2.71728 21.1768 2.47775 22 2.1122C21.394 3.02026 20.6308 3.81124 19.7477 4.45029Z"></path></svg></a>
  </div>
</div>
<p>A smart contract is simply a computer program running on TON Blockchain - or more exactly its <a href="https://ton-blockchain.github.io/docs/tvm.pdf">TVM</a> (TON Virtual Machine). The contract is made of code (compiled TVM instructions) and data (persistent state) that are stored in some address on TON Blockchain.</p>
<p>In the world of blockchain, <em>code is law</em>, meaning that instead of lawyers and papers, computer instructions define in absolute terms the rules of interaction between the different users of the contract. Before engaging with any smart contract as a user, you're expected to review its code and thus understand its terms of agreement. Accordingly, we'll make an effort to make our contract as easy to read as possible, so its users could understand what they're getting into.</p>
<h2 id="dappsdecentralizedapplications">Dapps - decentralized applications</h2>
<p>Smart contracts are a key part of <em>decentralized apps</em> - a special type of application invented in the blockchain era, that does not depend on any single entity to run it. Unlike the app Uber, for example, which depends on the company Uber Inc to run it - a <em>decentralized Uber</em> would allow riders and drivers to interact directly (order, pay for and fulfill rides) without any intermediary like Uber Inc. Dapps are also unstoppable - if we don't depend on anyone specific to run them, nobody can take them down.</p>
<p>Dapps on TON Blockchain are usually made of 2 main projects:</p>
<ul>
<li><p>Smart contracts in the <a href="https://ton.org/docs/develop/func/overview">FunC</a> programming language that are deployed on-chain - these act as the <em>backend server</em> of the app, with a <em>database</em> for persistent storage.</p></li>
<li><p>Web frontend for interacting with the dapp from a web browser - this acts as the <em>frontend</em> or <em>client</em>, normally with special support for Telegram messenger in the form of a <a href="https://core.telegram.org/bots/webapps">Telegram Web App</a>.</p></li>
</ul>
<p>Throughout this series of tutorials, we will build a full dapp together and see detailed implementations of both projects.</p>
<h2 id="step1defineourfirstsmartcontract">Step 1: Define our first smart contract</h2>
<p>So what are we going to build? Our smart contract will be quite simple:</p>
<p>Its main feature is to hold a <em>counter</em>. The counter will start at some number, and allow users to send <em>increment</em> transactions to the contract, which will in turn increase the counter value by 1. The contract will also have a getter function that will allow any user to query the current value of the counter.</p>
<p>In later tutorials we will make this contract a little more advanced and allow TON coins that are deposited in it to be withdrawn by a special admin role. This admin will also be able to transfer ownership to a different admin and more.</p>
<h2 id="step2setupyourlocalmachine">Step 2: Set up your local machine</h2>
<p>Before we can start writing code, we need to install certain developer tools on our computer.</p>
<p>For convenience, our development environment will rely on several clever scripts for testing, compiling and deploying our code. The most convenient language for these scripts is JavaScript, executed by an engine called Node.js. The installation instructions are <a href="https://nodejs.org/">here</a>. We will need a fairly recent version of node like v18. You can verify your nodejs version by running <code>node -v</code> in terminal.</p>
<p>You will also need a decent IDE with FunC and TypeScript support. I recommend <a href="https://code.visualstudio.com/">Visual Studio Code</a> - it's free and open source. Also install the <a href="https://marketplace.visualstudio.com/items?itemName=tonwhales.func-vscode">FunC Plugin</a> to add syntax highlighting for the FunC language.</p>
<h2 id="step3setuptheproject">Step 3: Set up the project</h2>
<p>Let's open a terminal in the project directory where you want to place your project. When you run the following command, be sure to choose "Counter" as the contract name and select "an empty contract (FunC)" from the list of templates. This will help prevent any issues in the future.</p>
<pre><code class="console language-console">npm create ton@latest
</code></pre>
<p>This will create a new project with a preconfigured structure, which includes a workflow for developing, testing, and deploying smart contracts using the Blueprint SDK. The project structure will initially consist of four directories: <code>contracts</code>, <code>wrappers</code>, <code>tests</code>, and <code>scripts</code>. Later on, we will also create a <code>build</code> directory.</p>
<p>And finally, execute the following command to open a folder, allowing us to proceed with the tutorial:</p>
<pre><code class="console language-console">cd your_project_directory
</code></pre>
<h2 id="step4structuringoursmartcontract">Step 4: Structuring our smart contract</h2>
<p>Much like everything else in life, smart contracts in FunC are divided into 3 sections. These sections are: <em>storage</em>, <em>messages</em> and <em>getters</em>.</p>
<p>The <strong>storage</strong> section deals with our contract's persistent data. Our contract will have to store data between calls from different users, for example the value of our <em>counter</em> variable. To write this data to state storage, we will need a write/encode function and to read this data back from state storage, we will need a read/decode function.</p>
<p>The <strong>messages</strong> section deals with messages sent to our contract. The main form of interaction with contracts on TON Blockchain is by sending them messages. We mentioned before that our contract will need to support a variety of actions like <em>increment</em>, <em>deposit</em>, <em>withdraw</em> and <em>transfer ownership</em>. All of these operations are performed by users as transactions. These operations are not read-only because they change something in the contract's persistent state.</p>
<p>The <strong>getters</strong> section deals with read-only interactions that don't change state. For example, we would want to allow users to query the value of our <em>counter</em>, so we can implement a getter for that. We've also mentioned that the contract has a special <em>owner</em>, so what about a getter to query that. Since our contract can hold money (TON coins), another useful getter could be to query the current balance.</p>
<h2 id="step5implementthecountercontract">Step 5: Implement the Counter contract</h2>
<p>We're about to write our first lines in FunC! Our first task would be to implement the <em>counter</em> feature of our contract.</p>
<p>The FunC programming language is very similar to the <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C language</a>. It has strict types, which is a good idea, since compilation errors will help us spot contract mistakes early on. The language was designed specifically for TON Blockchain, so you will not find a lot of documentation beyond the <a href="https://ton.org/docs/develop/func/overview">official FunC docs</a>.</p>
<p>Before the first section, please remember to keep the following line of code at the beginning of the file to import the standard library, as its absence can cause issues later on.</p>
<pre><code class="func language-func">#include "imports/stdlib.fc";
</code></pre>
<h3 id="storage">Storage</h3>
<p>Let's start with the first section, <em>storage</em>, and implement two utility functions (which we will use later) for reading and writing variables to the contract's persistent state - <code>load_data()</code> and <code>save_data()</code>. The primary variable will be the counter value. We must persist this value to storage because we need to remember it between calls. The appropriate type for our counter variable is <code>int</code>. Notice <a href="https://ton.org/docs/develop/func/types#atomic-types">in the docs</a> that the <code>int</code> TVM runtime type is always 257 bit long (256 bit signed) so it can hold huge huge numbers - I'm pretty sure the universe has less than 2^256 atoms in it, so you'll never have a number so large that you can't fit in it. Storing the full 257 bits in blockchain storage is somewhat wasteful because the contract pays rent proportionally to the total amount of data it keeps. To optimize costs, let's keep in persistent storage just the lowest 64 bits - capping our counter's maximum value at 2^64 which should be enough:</p>
<pre><code class="func language-func">(int) load_data() inline {                 ;; read function declaration - returns int as result
  var ds = get_data().begin_parse();       ;; load the storage cell and start parsing as a slice
  return (ds~load_uint(64));               ;; read a 64 bit unsigned int from the slice and return it
}

() save_data(int counter) impure inline {  ;; write function declaration - takes an int as arg
  set_data(begin_cell()                    ;; store the storage cell and create it with a builder
    .store_uint(counter, 64)               ;; write a 64 bit unsigned int to the builder
    .end_cell());                          ;; convert the builder to a cell
}
</code></pre>
<p>The standard library functions <code>get_data()</code> and <code>set_data()</code> are documented <a href="https://ton.org/docs/develop/func/stdlib#persistent-storage-save-and-load">here</a> and load/store the storage cell. We will cover <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>cells</em></a> in detail in future posts of this series. Cells are read from using the <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>slice</em></a> type (an array of bits) and written to using the <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>builder</em></a> type. The various methods that you see are all taken from the <a href="https://ton.org/docs/develop/func/stdlib">standard library</a>. Also notice two interesting function modifiers that appear in the declarations - <a href="https://ton.org/docs/develop/func/functions#inline-specifier"><em>inline</em></a> and <a href="https://ton.org/docs/develop/func/functions#impure-specifier"><em>impure</em></a>.</p>
<h3 id="messages">Messages</h3>
<p>Let's continue to the next section, <em>messages</em>, and implement the main message handler of our contract - <code>recv_internal()</code>. This is the primary entry point of our contract. It runs whenever a message is sent as a transaction to the contract by another contract or by a user's wallet contract:</p>
<pre><code class="func language-func">() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                              ;; return successfully and accept an empty message
  }
  int op = in_msg_body~load_uint(32);       ;; parse the operation type encoded in the beginning of msg body
  var (counter) = load_data();              ;; call our read utility function to load values from storage
  if (op == 1) {                            ;; handle op #1 = increment
    save_data(counter + 1);                 ;; call our write utility function to persist values to storage
  }
}
</code></pre>
<p>Messages sent between contracts are called <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">internal messages</a>. TON also supports <a href="https://ton.org/docs/develop/smart-contracts/messages">external messages</a> through the handler <code>recv_external()</code>, but as a dapp developer you're never expected to use them. External messages are used for very specific cases, mainly when implementing wallet contracts, that you would normally never have to write by yourself. You can safely ignore them.</p>
<p>Internal messages received by the contract may be empty. This is what happens for example when somebody sends TON coins to the contract from their wallet. This is useful for funding the contract so it can pay fees. In order to be able to receive those incoming transfers we will have to return successfully when an empty message arrives.</p>
<p>If an incoming message is not empty, the first thing to do is read its operation type. By convention, internal messages are <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">encoded</a> with a 32 bit unsigned int in the beginning that acts as operation type (op for short). We are free to assign any serial numbers we want to our different ops. In this case, we've assigned the number <code>1</code> to the <em>increment</em> action, which is handled by writing back to persistent state the current value counter plus 1.</p>
<h3 id="getters">Getters</h3>
<p>Our last section, as you recall, is <em>getters</em>. Let's implement a simple getter that will allow users to query the counter value:</p>
<pre><code class="func language-func">int counter() method_id {        ;; getter declaration - returns int as result
  var (counter) = load_data();   ;; call our read utility function to load value
  return counter;
}
</code></pre>
<p>We can choose what input arguments the getter takes as input and what output it returns as result. Also notice the function modifier appearing in the declaration - <a href="https://ton.org/docs/develop/func/functions#method_id"><em>method_id</em></a>. It is customary to place <code>method_id</code> on all getters.</p>
<p>That's it. We completed our 3 sections and the first version of our contract is ready. To get the complete code, simply concat the 3 snippets above and replace the existing code in <code>contracts/counter.fc</code>. This will be the FunC (<code>.fc</code> file extension) source file of our contract. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.fc">this</a>.</p>
<h2 id="step6buildthecountercontract">Step 6: Build the counter contract</h2>
<p>Right now, the contract is just FunC source code. To get it to run on-chain, we need to convert it to TVM <a href="https://ton.org/docs/learn/tvm-instructions/instructions">bytecode</a>.</p>
<p>In TON, we don't compile FunC directly to bytecode, but instead go through another programming language called <a href="https://ton-blockchain.github.io/docs/fiftbase.pdf">Fift</a>. Just like FunC, Fift is another language that was designed specifically for TON Blockchain. It's a low level language that is very close to TVM opcodes. For us regular mortals, Fift is not very useful, so unless you're planning on some extra advanced things, I believe you can safely ignore it for now.</p>
<p>Since we're using func-js for building, it would be a good idea to create a directory where we can store the build result. To do this, open the terminal and run the following command:</p>
<pre><code class="console language-console">mkdir build
</code></pre>
<p>The func-js package contains everything we need to compile our contract to bytecode. To use it, open terminal in the project directory and run the following:</p>
<pre><code class="console language-console">npx func-js contracts/counter.fc --boc build/counter.cell
</code></pre>
<p>The build should succeed, with the output of this command being a new file - <code>counter.cell</code>. This is a binary file that finally contains the TVM bytecode in cell format that is ready to be deployed on-chain. This will actually be the only file we need for deployment moving forward (we won't need the FunC source file).</p>
<h2 id="step7prepareinitdatafordeployingonchain">Step 7: Prepare init data for deploying on-chain</h2>
<p>Now that our contract has been compiled to bytecode, we can finally see it in action running on-chain. The act of uploading the bytecode to the blockchain is called <em>deployment</em>. The deployment result would be an address where the contract resides. This address will allow us to communicate with this specific contract instance later on and send it transactions.</p>
<p>There are two variations of TON Blockchain we can deploy to - <em>mainnet</em> and <em>testnet</em>. We covered both in the previous tutorial. Personally, I almost never deploy to testnet. There are far better ways to gain confidence that my code is working as expected. The primary of which is writing a dedicated <em>test suite</em>. We will cover this in detail in one of the next tutorials. For now, let's assume the code is working perfectly and no further debugging is required.</p>
<h3 id="initarguments">Init arguments</h3>
<p>The new address of our deployed contract in TON depends on only two things - the deployed bytecode (initial code) and the initial contract storage (initial data). You can say that the address is some derivation of the hash of both. If two different developers were to deploy the exact same code with the exact same initialization data, they would collide.</p>
<p>The bytecode part is easy, we have that ready as a cell in the file <code>counter.cell</code> that we compiled in step 6. Now what about the initial contract storage? As you recall, the format of our persistent storage data was decided when we implemented the function <code>save_data()</code> of our contract FunC source. Our storage layout was very simple - just one unsigned int of 64 bit holding the counter value. Therefore, to initialize our contract, we would need to generate a data cell holding some arbitrary initial uint64 value - for example the number <code>1</code>.</p>
<h3 id="interfaceclass">Interface class</h3>
<p>The recommended way to interact with contracts is to create a small TypeScript class that will implement the interaction interface with the contract. We're using the project structure created by Blueprint, but we're still working on low-level aspects.
Use the following code in <code>wrappers/Counter.ts</code> to create the initial data cell for deployment:</p>
<pre><code class="ts language-ts">import { Contract, ContractProvider, Sender, Address, Cell, contractAddress, beginCell } from "@ton/core";

export default class Counter implements Contract {

  static createForDeploy(code: Cell, initialCounterValue: number): Counter {
    const data = beginCell()
      .storeUint(initialCounterValue, 64)
      .endCell();
    const workchain = 0; // deploy to workchain 0
    const address = contractAddress(workchain, { code, data });
    return new Counter(address, { code, data });
  }

  constructor(readonly address: Address, readonly init?: { code: Cell, data: Cell }) {}
}
</code></pre>
<p>Notice a few interesting things about this TypeScript code. First, it depends on the package <a href="https://www.npmjs.com/package/@ton/core">@ton/core</a> instead of <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a>, which contains a small subset of base types and is therefore slower to change - an important feature when building a stable interface for our contract. Second, the code that creates the data cell mimics the FunC API and is almost identical to our <code>save_data()</code> FunC function. Third, we can see the derivation of the contract address from the code cell and data cell using the function <code>contractAddress</code>.</p>
<p>The actual deployment involves sending the first message that will cause our contract to be deployed. We can piggyback any message that is directed towards our contract. This can even be the increment message with op #1, but we will do something simpler. We will just send some TON coins to our contract (an empty message) and piggyback that. Let's make this part of our interface. Add the function <code>sendDeploy()</code> to <code>wrappers/Counter.ts</code> - this function will send the deployment message:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async sendDeploy(provider: ContractProvider, via: Sender) {
    await provider.internal(via, {
      value: "0.01", // send 0.01 TON to contract for rent
      bounce: false
    });
  }

// }
</code></pre>
<p>In every deployment we need to send some TON coins to our contract so that its balance is not zero. Contracts need to continually pay rent fees otherwise they risk being deleted. According to the <a href="https://ton.org/docs/develop/smart-contracts/fees#storage-fee">docs</a>, storage fees are about 4 TON per MB per year. Since our contract stores less than 1 KB, a balance of 0.01 TON should be enough for more than 2 years. In any case you can always check this in an explorer and send more TON to the contract if it runs low.</p>
<p>The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step7.ts">this</a>.</p>
<h2 id="step8deploythecontractonchain">Step 8: Deploy the contract on-chain</h2>
<p>Communicating with the live network for the deployment will require an RPC service provider - similar to <a href="https://infura.io">Infura</a> on Ethereum. These providers run TON Blockchain nodes and allow us to communicate with them over HTTP. <a href="https://orbs.com/ton-access">TON Access</a> is an awesome service that will provide us with unthrottled API access for free. It's also decentralized, which is the preferred way to access the network.</p>
<p>Install it by opening terminal in the project directory and running:</p>
<pre><code class="console language-console">npm install @orbs-network/ton-access
</code></pre>
<p>The deployment is going to cost gas and should be done through a wallet that will fund it. I'm assuming that you have some familiarity with TON wallets and how they're derived from 24 word secret mnemonics. If not, be sure to follow the previous tutorial in this series.</p>
<p>As you recall from the previous tutorial, TON wallets can come in multiple versions. The code below relies on "wallet v4 r2", if your wallet is different, either switch <a href="https://tonkeeper.com">Tonkeeper</a> through "Settings" to this version, or modify the code below to use your version. Also remember to use a wallet works with the correct network you've chosen - testnet or mainnet.</p>
<p>Replace the current code in <code>scripts/deployCounter.ts</code> with a script that will use the interface class we have just written:</p>
<pre><code class="ts language-ts">import * as fs from "fs";
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, Cell, WalletContractV4 } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class from step 7

export async function run() {
  // initialize ton rpc client on mainnet
  const endpoint = await getHttpEndpoint();
  const client = new TonClient({ endpoint });

  // prepare Counter's initial code and data cells for deployment
  const counterCode = Cell.fromBoc(fs.readFileSync("build/counter.cell"))[0]; // compilation output from step 6
  const initialCounterValue = Date.now(); // to avoid collisions use current number of milliseconds since epoch as initial value
  const counter = Counter.createForDeploy(counterCode, initialCounterValue);

  // exit if contract is already deployed
  console.log("contract address:", counter.address.toString());
  if (await client.isContractDeployed(counter.address)) {
    return console.log("Counter already deployed");
  }

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // send the deploy transaction
  const counterContract = client.open(counter);
  await counterContract.sendDeploy(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for deploy transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("deploy transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre>
<p>Before running this code, make sure you have enough TON in your wallet for the gas payments and the TON sent to the contract during the deploy.</p>
<p>Another thing to watch out for is collisions between different users of this tutorial. As you recall, if the code and initial data of two contracts are identical, they will have the same address. If all followers of this tutorial would choose initial counter value of <code>1</code> - then all of them would collide and only the first would actually deploy the contract. To make sure this doesn't happen, the code above initializes the counter value to the current number of milliseconds since the epoch (something like 1674253934361). This guarantees that your contract for deployment is unique.</p>
<p>To deploy a contract using our script, run the following command in the terminal and follow the on-screen instructions:</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>If you have network connectivity issues and get errors like backend nodes unhealthy or timeouts, please join the <a href="https://t.me/TONAccessSupport">Telegram support chat</a> for TON access to get assistance. A common mistake is trying to use a wallet contract that isn't deployed or funded. This can happen if you're setting the wrong wallet version. As explained in the previous tutorial, check your wallet address in an <a href="https://tonscan.org">explorer</a> and if your wallet has a different version from "wallet v4 r2" you will need to modify slightly the code above. Let's say for example that your version is "wallet v3 r2", then replace <code>WalletContractV4</code> with <code>WalletContractV3R2</code>.</p>
<p>The script will print the newly deployed contract address - mine is <code>EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb</code>. You can open your address in an <a href="https://tonscan.org">explorer</a> to verify that the deploy went smoothly. This is what it should look like:</p>
<p><img src="https://i.imgur.com/SLR7nmE.png" width=600 /><br></p>
<p>Write down your deployed contract address. We're going to use it in the next step.</p>
<h2 id="step9callagetteronthedeployedcontract">Step 9: Call a getter on the deployed contract</h2>
<p>There are two ways to interact with a smart contract - calling a getter to read data from it or sending a message that can potentially change its state (write). We should support these interactions in the contract interface class that we created in step 7.</p>
<p>Anyone who wants to access the contract from TypeScript would simply use this interface class. This is excellent for separation of responsibilities within your team. The developer of the contract can provide this class to the developer of the client to abstract away implementation details such as how messages should be encoded in the binary level. Let's start with the getter.</p>
<h3 id="interfaceclass-1">Interface class</h3>
<p>Add the following to <code>wrappers/Counter.ts</code>:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async getCounter(provider: ContractProvider) {
    const { stack } = await provider.get("counter", []);
    return stack.readBigNumber();
  }

// }
</code></pre>
<p>Notice that methods in the interface class that call getters must start with the word <code>get</code>. This prefix is a requirement of the <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a> TypeScript library. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step9.ts">this</a>.</p>
<h3 id="executingthecall">Executing the call</h3>
<p>Calling a getter is free and does not cost gas. The reason is that this call is read-only, so it does not require consensus by the validators and is not stored in a block on-chain for all eternity like transaction are.</p>
<p>Let's create a new script called <code>getCounter.ts</code> in the <code>scripts</code> folder and use our shiny interface class to make the call. We're going to emulate a different developer interacting with our contract and since the contract is already deployed, they are likely to access it by address. Be sure to replace my deployed contract address with yours in the code below:</p>
<pre><code class="ts language-ts">import { getHttpEndpoint } from "@orbs-network/ton-access";
import { TonClient, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on mainnet
  const endpoint = await getHttpEndpoint();
  const client = new TonClient({ endpoint });

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // call the getter on chain
  const counterValue = await counterContract.getCounter();
  console.log("value:", counterValue.toString());
}
</code></pre>
<p>As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "getCounter" from the list of available scripts.</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>Make a note of the current counter value. After we send the increment message in the next step we would like to confirm that this value indeed increases by 1.</p>
<p>Another interesting thing to remember is that getters are only accessible off-chain, for example from a JavaScript client making a call through an RPC service provider. In particular, this means that contracts cannot call getters on other contracts.</p>
<h2 id="step10sendatransactiontothedeployedcontract">Step 10: Send a transaction to the deployed contract</h2>
<p>Unlike getters that are read-only, messages can write and change contract state in storage. In our contract implementation we handled messages in <code>recv_internal()</code> and assigned op #1 = <em>increment</em>. Sending messages costs gas and requires payment in TON coin. The reason is that this operation is not read-only, so it requires waiting for consensus by the validators and is stored as a transaction in a block on-chain for all eternity. We will send less TON coin this time since this action is much cheaper than the deployment.</p>
<h3 id="interfaceclass-2">Interface class</h3>
<p>Add the following to <code>wrappers/Counter.ts</code>:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async sendIncrement(provider: ContractProvider, via: Sender) {
    const messageBody = beginCell()
      .storeUint(1, 32) // op (op #1 = increment)
      .storeUint(0, 64) // query id
      .endCell();
    await provider.internal(via, {
      value: "0.002", // send 0.002 TON for gas
      body: messageBody
    });
  }

// }
</code></pre>
<p>As you recall, the increment message is an <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">internal message</a> that is encoded by convention with a 32 bit unsigned int in the beginning to describe the op and a 64 bit unsigned int after to describe the query id. The query id is relevant for messages that expect a response message to be sent back (the request and the response share the same query id).</p>
<p>Notice that methods in the interface class that send messages must start with the word <code>send</code>, another prefix requirement of the <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a> library. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step10.ts">this</a>.</p>
<h3 id="executingthesend">Executing the send</h3>
<p>The messages can be sent from any TON wallet, not necessarily the deployer wallet. Create a new script <code>sendIncrement.ts</code> in the <code>scripts</code> folder and use your wallet to fund the send:</p>
<pre><code class="ts language-ts">import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, WalletContractV4, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on mainnet
  const endpoint = await getHttpEndpoint();
  const client = new TonClient({ endpoint });

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // send the increment transaction
  await counterContract.sendIncrement(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre>
<p>As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "sendIncrement" from the list of available scripts.</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>Notice that the message will take a few seconds to be processed by validators and will only change contract state after it has been processed. The normal wait time is a block or two, since validators need to produce a new block that contains our sent transaction. The op that was sent above is #1 = <em>increment</em>, which means that after processing, the counter value will increase by 1. Verify this by re-running the script from step 9 to print the new counter value.</p>
<p>Messages can be sent to our contract by other contracts. This means a different contract can increment our counter. This allows the TON ecosystem to create composable apps and protocols that build on top of each other and interact in unforeseen ways.</p>
<h2 id="reward">Reward</h2>
<p>Congratulations on successfully completing this tutorial! Before we conclude, let's take a quick look at the exciting reward awaiting you from the <a target="_blank" href="https://getgems.io/collection/EQA4RIS6uxt1GZkTTr19Wy423NZtcG0pRy29lg55X-qYq-Tf">"TON Masters"</a> collection:</p>
<video style="border-radius: 10pt; margin: 25pt auto; display: block;" width="40%" autoplay loop muted playsinline>
  <source src="https://ton-devrel.s3.eu-central-1.amazonaws.com/tal-tutorials/2-smart/video.mp4" type="video/mp4">
</video>
<p>Ready to claim your reward? Simply scan the QR code below or click <a href="ton://transfer/EQCZ52LU4PsK71IVjn4Ur599R4ZdsnT9ToAEqysot628BEdo?bin=te6cckEBAQEABgAACACZ_fWVyQMr&amount=50000000">here</a>:
<img src="https://i.imgur.com/GEuOQjr.png" width=300 alt="QR-code" style="display: block; margin-left: auto; margin-right: auto; width: 50%;"/></p>
<h2 id="conclusion">Conclusion</h2>
<p>For your convenience, all the code in this tutorial is available in executable form <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test">here</a>.</p>
<p>In this tutorial we handled the build and deploy processes manually, mostly so we can understand what happens under the hood. When creating a new contract project, you can have these processes managed automatically by an awesome dev tool called <a href="https://github.com/ton-community/blueprint">Blueprint</a>. To create a new contract project with Blueprint, run in terminal and follow the on-screen instructions:</p>
<pre><code class="console language-console">npm create ton@latest
</code></pre>
<p>If you found a mistake in this tutorial, please <a href="https://github.com/ton-community/tutorials/pulls">submit a PR</a> and help us fix it. This tutorial platform is fully open source and available on <a href="https://github.com/ton-community/tutorials">https://github.com/ton-community/tutorials</a>.</p>
<p>Happy coding!</p>
         </div>
        
         <div class="post" data-combination="testnet-npmton">
            <h1 id="tonhelloworldpart2stepbystepguideforwritingyourfirstsmartcontract">TON Hello World part 2: Step by step guide for writing your first smart contract</h1>
<div class="author">
  <img class="face" src="../assets/authors/talkol.jpg" />
  <span>by Tal Kol</span>
  <div>
    <a class="social" rel="noreferrer" href="https://t.me/talkol"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="FollowCard_icon__0yJs8" style="fill: currentcolor;"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM12.4298 8.85893C11.2626 9.3444 8.92989 10.3492 5.43165 11.8733C4.86359 12.0992 4.56601 12.3202 4.53892 12.5363C4.49314 12.9015 4.95047 13.0453 5.57323 13.2411C5.65794 13.2678 5.74571 13.2954 5.83569 13.3246C6.44839 13.5238 7.27258 13.7568 7.70104 13.766C8.0897 13.7744 8.52348 13.6142 9.0024 13.2853C12.2709 11.079 13.9581 9.96381 14.0641 9.93977C14.1388 9.92281 14.2424 9.90148 14.3125 9.96385C14.3827 10.0262 14.3758 10.1443 14.3684 10.176C14.3231 10.3691 12.5279 12.0381 11.5989 12.9018C11.3093 13.171 11.1038 13.362 11.0618 13.4056C10.9678 13.5034 10.8719 13.5958 10.7797 13.6846C10.2105 14.2333 9.78367 14.6448 10.8034 15.3168C11.2934 15.6397 11.6855 15.9067 12.0767 16.1731C12.5039 16.4641 12.93 16.7543 13.4814 17.1157C13.6218 17.2078 13.756 17.3034 13.8866 17.3965C14.3838 17.751 14.8305 18.0694 15.3823 18.0186C15.703 17.9891 16.0342 17.6876 16.2024 16.7884C16.6 14.6632 17.3814 10.0585 17.562 8.16098C17.5778 7.99473 17.5579 7.78197 17.5419 7.68857C17.5259 7.59518 17.4925 7.46211 17.3711 7.3636C17.2273 7.24694 17.0054 7.22234 16.9061 7.22408C16.4548 7.23203 15.7623 7.47282 12.4298 8.85893Z"></path></svg></a>
  <a class="social" rel="noreferrer" href="https://twitter.com/koltal"><svg viewBox="0 0 22 18" fill="none" xmlns="http://www.w3.org/2000/svg" class="FollowCard_icon__0yJs8" style="fill: currentcolor;"><path d="M19.7477 4.45029C19.7611 4.64423 19.7611 4.83818 19.7611 5.03391C19.7611 10.998 15.2208 17.8764 6.91863 17.8764V17.8728C4.46614 17.8764 2.06459 17.1739 0 15.8494C0.356612 15.8923 0.715011 15.9137 1.0743 15.9146C3.10672 15.9164 5.08105 15.2344 6.67999 13.9787C4.74857 13.9421 3.05489 12.6827 2.46321 10.8443C3.13979 10.9748 3.83693 10.9479 4.501 10.7665C2.39529 10.3411 0.880358 8.49099 0.880358 6.34238C0.880358 6.32272 0.880358 6.30395 0.880358 6.28518C1.50778 6.63464 2.21028 6.82859 2.92886 6.85004C0.945602 5.52459 0.334268 2.8862 1.53191 0.823391C3.82352 3.64322 7.20463 5.35746 10.8342 5.53889C10.4704 3.97123 10.9674 2.32849 12.14 1.22648C13.9579 -0.482398 16.8171 -0.394809 18.5259 1.42221C19.5368 1.2229 20.5056 0.851992 21.3922 0.326458C21.0553 1.37127 20.3501 2.25878 19.4081 2.82274C20.3027 2.71728 21.1768 2.47775 22 2.1122C21.394 3.02026 20.6308 3.81124 19.7477 4.45029Z"></path></svg></a>
  </div>
</div>
<p>A smart contract is simply a computer program running on TON Blockchain - or more exactly its <a href="https://ton-blockchain.github.io/docs/tvm.pdf">TVM</a> (TON Virtual Machine). The contract is made of code (compiled TVM instructions) and data (persistent state) that are stored in some address on TON Blockchain.</p>
<p>In the world of blockchain, <em>code is law</em>, meaning that instead of lawyers and papers, computer instructions define in absolute terms the rules of interaction between the different users of the contract. Before engaging with any smart contract as a user, you're expected to review its code and thus understand its terms of agreement. Accordingly, we'll make an effort to make our contract as easy to read as possible, so its users could understand what they're getting into.</p>
<h2 id="dappsdecentralizedapplications">Dapps - decentralized applications</h2>
<p>Smart contracts are a key part of <em>decentralized apps</em> - a special type of application invented in the blockchain era, that does not depend on any single entity to run it. Unlike the app Uber, for example, which depends on the company Uber Inc to run it - a <em>decentralized Uber</em> would allow riders and drivers to interact directly (order, pay for and fulfill rides) without any intermediary like Uber Inc. Dapps are also unstoppable - if we don't depend on anyone specific to run them, nobody can take them down.</p>
<p>Dapps on TON Blockchain are usually made of 2 main projects:</p>
<ul>
<li><p>Smart contracts in the <a href="https://ton.org/docs/develop/func/overview">FunC</a> programming language that are deployed on-chain - these act as the <em>backend server</em> of the app, with a <em>database</em> for persistent storage.</p></li>
<li><p>Web frontend for interacting with the dapp from a web browser - this acts as the <em>frontend</em> or <em>client</em>, normally with special support for Telegram messenger in the form of a <a href="https://core.telegram.org/bots/webapps">Telegram Web App</a>.</p></li>
</ul>
<p>Throughout this series of tutorials, we will build a full dapp together and see detailed implementations of both projects.</p>
<h2 id="step1defineourfirstsmartcontract">Step 1: Define our first smart contract</h2>
<p>So what are we going to build? Our smart contract will be quite simple:</p>
<p>Its main feature is to hold a <em>counter</em>. The counter will start at some number, and allow users to send <em>increment</em> transactions to the contract, which will in turn increase the counter value by 1. The contract will also have a getter function that will allow any user to query the current value of the counter.</p>
<p>In later tutorials we will make this contract a little more advanced and allow TON coins that are deposited in it to be withdrawn by a special admin role. This admin will also be able to transfer ownership to a different admin and more.</p>
<h2 id="step2setupyourlocalmachine">Step 2: Set up your local machine</h2>
<p>Before we can start writing code, we need to install certain developer tools on our computer.</p>
<p>For convenience, our development environment will rely on several clever scripts for testing, compiling and deploying our code. The most convenient language for these scripts is JavaScript, executed by an engine called Node.js. The installation instructions are <a href="https://nodejs.org/">here</a>. We will need a fairly recent version of node like v18. You can verify your nodejs version by running <code>node -v</code> in terminal.</p>
<p>You will also need a decent IDE with FunC and TypeScript support. I recommend <a href="https://code.visualstudio.com/">Visual Studio Code</a> - it's free and open source. Also install the <a href="https://marketplace.visualstudio.com/items?itemName=tonwhales.func-vscode">FunC Plugin</a> to add syntax highlighting for the FunC language.</p>
<h2 id="step3setuptheproject">Step 3: Set up the project</h2>
<p>Let's open a terminal in the project directory where you want to place your project. When you run the following command, be sure to choose "Counter" as the contract name and select "an empty contract (FunC)" from the list of templates. This will help prevent any issues in the future.</p>
<pre><code class="console language-console">npm create ton@latest
</code></pre>
<p>This will create a new project with a preconfigured structure, which includes a workflow for developing, testing, and deploying smart contracts using the Blueprint SDK. The project structure will initially consist of four directories: <code>contracts</code>, <code>wrappers</code>, <code>tests</code>, and <code>scripts</code>. Later on, we will also create a <code>build</code> directory.</p>
<p>And finally, execute the following command to open a folder, allowing us to proceed with the tutorial:</p>
<pre><code class="console language-console">cd your_project_directory
</code></pre>
<h2 id="step4structuringoursmartcontract">Step 4: Structuring our smart contract</h2>
<p>Much like everything else in life, smart contracts in FunC are divided into 3 sections. These sections are: <em>storage</em>, <em>messages</em> and <em>getters</em>.</p>
<p>The <strong>storage</strong> section deals with our contract's persistent data. Our contract will have to store data between calls from different users, for example the value of our <em>counter</em> variable. To write this data to state storage, we will need a write/encode function and to read this data back from state storage, we will need a read/decode function.</p>
<p>The <strong>messages</strong> section deals with messages sent to our contract. The main form of interaction with contracts on TON Blockchain is by sending them messages. We mentioned before that our contract will need to support a variety of actions like <em>increment</em>, <em>deposit</em>, <em>withdraw</em> and <em>transfer ownership</em>. All of these operations are performed by users as transactions. These operations are not read-only because they change something in the contract's persistent state.</p>
<p>The <strong>getters</strong> section deals with read-only interactions that don't change state. For example, we would want to allow users to query the value of our <em>counter</em>, so we can implement a getter for that. We've also mentioned that the contract has a special <em>owner</em>, so what about a getter to query that. Since our contract can hold money (TON coins), another useful getter could be to query the current balance.</p>
<h2 id="step5implementthecountercontract">Step 5: Implement the Counter contract</h2>
<p>We're about to write our first lines in FunC! Our first task would be to implement the <em>counter</em> feature of our contract.</p>
<p>The FunC programming language is very similar to the <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C language</a>. It has strict types, which is a good idea, since compilation errors will help us spot contract mistakes early on. The language was designed specifically for TON Blockchain, so you will not find a lot of documentation beyond the <a href="https://ton.org/docs/develop/func/overview">official FunC docs</a>.</p>
<p>Before the first section, please remember to keep the following line of code at the beginning of the file to import the standard library, as its absence can cause issues later on.</p>
<pre><code class="func language-func">#include "imports/stdlib.fc";
</code></pre>
<h3 id="storage">Storage</h3>
<p>Let's start with the first section, <em>storage</em>, and implement two utility functions (which we will use later) for reading and writing variables to the contract's persistent state - <code>load_data()</code> and <code>save_data()</code>. The primary variable will be the counter value. We must persist this value to storage because we need to remember it between calls. The appropriate type for our counter variable is <code>int</code>. Notice <a href="https://ton.org/docs/develop/func/types#atomic-types">in the docs</a> that the <code>int</code> TVM runtime type is always 257 bit long (256 bit signed) so it can hold huge huge numbers - I'm pretty sure the universe has less than 2^256 atoms in it, so you'll never have a number so large that you can't fit in it. Storing the full 257 bits in blockchain storage is somewhat wasteful because the contract pays rent proportionally to the total amount of data it keeps. To optimize costs, let's keep in persistent storage just the lowest 64 bits - capping our counter's maximum value at 2^64 which should be enough:</p>
<pre><code class="func language-func">(int) load_data() inline {                 ;; read function declaration - returns int as result
  var ds = get_data().begin_parse();       ;; load the storage cell and start parsing as a slice
  return (ds~load_uint(64));               ;; read a 64 bit unsigned int from the slice and return it
}

() save_data(int counter) impure inline {  ;; write function declaration - takes an int as arg
  set_data(begin_cell()                    ;; store the storage cell and create it with a builder
    .store_uint(counter, 64)               ;; write a 64 bit unsigned int to the builder
    .end_cell());                          ;; convert the builder to a cell
}
</code></pre>
<p>The standard library functions <code>get_data()</code> and <code>set_data()</code> are documented <a href="https://ton.org/docs/develop/func/stdlib#persistent-storage-save-and-load">here</a> and load/store the storage cell. We will cover <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>cells</em></a> in detail in future posts of this series. Cells are read from using the <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>slice</em></a> type (an array of bits) and written to using the <a href="https://ton.org/docs/develop/func/types#atomic-types"><em>builder</em></a> type. The various methods that you see are all taken from the <a href="https://ton.org/docs/develop/func/stdlib">standard library</a>. Also notice two interesting function modifiers that appear in the declarations - <a href="https://ton.org/docs/develop/func/functions#inline-specifier"><em>inline</em></a> and <a href="https://ton.org/docs/develop/func/functions#impure-specifier"><em>impure</em></a>.</p>
<h3 id="messages">Messages</h3>
<p>Let's continue to the next section, <em>messages</em>, and implement the main message handler of our contract - <code>recv_internal()</code>. This is the primary entry point of our contract. It runs whenever a message is sent as a transaction to the contract by another contract or by a user's wallet contract:</p>
<pre><code class="func language-func">() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                              ;; return successfully and accept an empty message
  }
  int op = in_msg_body~load_uint(32);       ;; parse the operation type encoded in the beginning of msg body
  var (counter) = load_data();              ;; call our read utility function to load values from storage
  if (op == 1) {                            ;; handle op #1 = increment
    save_data(counter + 1);                 ;; call our write utility function to persist values to storage
  }
}
</code></pre>
<p>Messages sent between contracts are called <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">internal messages</a>. TON also supports <a href="https://ton.org/docs/develop/smart-contracts/messages">external messages</a> through the handler <code>recv_external()</code>, but as a dapp developer you're never expected to use them. External messages are used for very specific cases, mainly when implementing wallet contracts, that you would normally never have to write by yourself. You can safely ignore them.</p>
<p>Internal messages received by the contract may be empty. This is what happens for example when somebody sends TON coins to the contract from their wallet. This is useful for funding the contract so it can pay fees. In order to be able to receive those incoming transfers we will have to return successfully when an empty message arrives.</p>
<p>If an incoming message is not empty, the first thing to do is read its operation type. By convention, internal messages are <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">encoded</a> with a 32 bit unsigned int in the beginning that acts as operation type (op for short). We are free to assign any serial numbers we want to our different ops. In this case, we've assigned the number <code>1</code> to the <em>increment</em> action, which is handled by writing back to persistent state the current value counter plus 1.</p>
<h3 id="getters">Getters</h3>
<p>Our last section, as you recall, is <em>getters</em>. Let's implement a simple getter that will allow users to query the counter value:</p>
<pre><code class="func language-func">int counter() method_id {        ;; getter declaration - returns int as result
  var (counter) = load_data();   ;; call our read utility function to load value
  return counter;
}
</code></pre>
<p>We can choose what input arguments the getter takes as input and what output it returns as result. Also notice the function modifier appearing in the declaration - <a href="https://ton.org/docs/develop/func/functions#method_id"><em>method_id</em></a>. It is customary to place <code>method_id</code> on all getters.</p>
<p>That's it. We completed our 3 sections and the first version of our contract is ready. To get the complete code, simply concat the 3 snippets above and replace the existing code in <code>contracts/counter.fc</code>. This will be the FunC (<code>.fc</code> file extension) source file of our contract. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.fc">this</a>.</p>
<h2 id="step6buildthecountercontract">Step 6: Build the counter contract</h2>
<p>Right now, the contract is just FunC source code. To get it to run on-chain, we need to convert it to TVM <a href="https://ton.org/docs/learn/tvm-instructions/instructions">bytecode</a>.</p>
<p>In TON, we don't compile FunC directly to bytecode, but instead go through another programming language called <a href="https://ton-blockchain.github.io/docs/fiftbase.pdf">Fift</a>. Just like FunC, Fift is another language that was designed specifically for TON Blockchain. It's a low level language that is very close to TVM opcodes. For us regular mortals, Fift is not very useful, so unless you're planning on some extra advanced things, I believe you can safely ignore it for now.</p>
<p>Since we're using func-js for building, it would be a good idea to create a directory where we can store the build result. To do this, open the terminal and run the following command:</p>
<pre><code class="console language-console">mkdir build
</code></pre>
<p>The func-js package contains everything we need to compile our contract to bytecode. To use it, open terminal in the project directory and run the following:</p>
<pre><code class="console language-console">npx func-js contracts/counter.fc --boc build/counter.cell
</code></pre>
<p>The build should succeed, with the output of this command being a new file - <code>counter.cell</code>. This is a binary file that finally contains the TVM bytecode in cell format that is ready to be deployed on-chain. This will actually be the only file we need for deployment moving forward (we won't need the FunC source file).</p>
<h2 id="step7prepareinitdatafordeployingonchain">Step 7: Prepare init data for deploying on-chain</h2>
<p>Now that our contract has been compiled to bytecode, we can finally see it in action running on-chain. The act of uploading the bytecode to the blockchain is called <em>deployment</em>. The deployment result would be an address where the contract resides. This address will allow us to communicate with this specific contract instance later on and send it transactions.</p>
<p>There are two variations of TON Blockchain we can deploy to - <em>mainnet</em> and <em>testnet</em>. We covered both in the previous tutorial. Personally, I almost never deploy to testnet. There are far better ways to gain confidence that my code is working as expected. The primary of which is writing a dedicated <em>test suite</em>. We will cover this in detail in one of the next tutorials. For now, let's assume the code is working perfectly and no further debugging is required.</p>
<h3 id="initarguments">Init arguments</h3>
<p>The new address of our deployed contract in TON depends on only two things - the deployed bytecode (initial code) and the initial contract storage (initial data). You can say that the address is some derivation of the hash of both. If two different developers were to deploy the exact same code with the exact same initialization data, they would collide.</p>
<p>The bytecode part is easy, we have that ready as a cell in the file <code>counter.cell</code> that we compiled in step 6. Now what about the initial contract storage? As you recall, the format of our persistent storage data was decided when we implemented the function <code>save_data()</code> of our contract FunC source. Our storage layout was very simple - just one unsigned int of 64 bit holding the counter value. Therefore, to initialize our contract, we would need to generate a data cell holding some arbitrary initial uint64 value - for example the number <code>1</code>.</p>
<h3 id="interfaceclass">Interface class</h3>
<p>The recommended way to interact with contracts is to create a small TypeScript class that will implement the interaction interface with the contract. We're using the project structure created by Blueprint, but we're still working on low-level aspects.
Use the following code in <code>wrappers/Counter.ts</code> to create the initial data cell for deployment:</p>
<pre><code class="ts language-ts">import { Contract, ContractProvider, Sender, Address, Cell, contractAddress, beginCell } from "@ton/core";

export default class Counter implements Contract {

  static createForDeploy(code: Cell, initialCounterValue: number): Counter {
    const data = beginCell()
      .storeUint(initialCounterValue, 64)
      .endCell();
    const workchain = 0; // deploy to workchain 0
    const address = contractAddress(workchain, { code, data });
    return new Counter(address, { code, data });
  }

  constructor(readonly address: Address, readonly init?: { code: Cell, data: Cell }) {}
}
</code></pre>
<p>Notice a few interesting things about this TypeScript code. First, it depends on the package <a href="https://www.npmjs.com/package/@ton/core">@ton/core</a> instead of <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a>, which contains a small subset of base types and is therefore slower to change - an important feature when building a stable interface for our contract. Second, the code that creates the data cell mimics the FunC API and is almost identical to our <code>save_data()</code> FunC function. Third, we can see the derivation of the contract address from the code cell and data cell using the function <code>contractAddress</code>.</p>
<p>The actual deployment involves sending the first message that will cause our contract to be deployed. We can piggyback any message that is directed towards our contract. This can even be the increment message with op #1, but we will do something simpler. We will just send some TON coins to our contract (an empty message) and piggyback that. Let's make this part of our interface. Add the function <code>sendDeploy()</code> to <code>wrappers/Counter.ts</code> - this function will send the deployment message:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async sendDeploy(provider: ContractProvider, via: Sender) {
    await provider.internal(via, {
      value: "0.01", // send 0.01 TON to contract for rent
      bounce: false
    });
  }

// }
</code></pre>
<p>In every deployment we need to send some TON coins to our contract so that its balance is not zero. Contracts need to continually pay rent fees otherwise they risk being deleted. According to the <a href="https://ton.org/docs/develop/smart-contracts/fees#storage-fee">docs</a>, storage fees are about 4 TON per MB per year. Since our contract stores less than 1 KB, a balance of 0.01 TON should be enough for more than 2 years. In any case you can always check this in an explorer and send more TON to the contract if it runs low.</p>
<p>The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step7.ts">this</a>.</p>
<h2 id="step8deploythecontractonchain">Step 8: Deploy the contract on-chain</h2>
<p>Communicating with the live network for the deployment will require an RPC service provider - similar to <a href="https://infura.io">Infura</a> on Ethereum. These providers run TON Blockchain nodes and allow us to communicate with them over HTTP. <a href="https://orbs.com/ton-access">TON Access</a> is an awesome service that will provide us with unthrottled API access for free. It's also decentralized, which is the preferred way to access the network.</p>
<p>Install it by opening terminal in the project directory and running:</p>
<pre><code class="console language-console">npm install @orbs-network/ton-access
</code></pre>
<p>The deployment is going to cost gas and should be done through a wallet that will fund it. I'm assuming that you have some familiarity with TON wallets and how they're derived from 24 word secret mnemonics. If not, be sure to follow the previous tutorial in this series.</p>
<p>As you recall from the previous tutorial, TON wallets can come in multiple versions. The code below relies on "wallet v4 r2", if your wallet is different, either switch <a href="https://tonkeeper.com">Tonkeeper</a> through "Settings" to this version, or modify the code below to use your version. Also remember to use a wallet works with the correct network you've chosen - testnet or mainnet.</p>
<p>Replace the current code in <code>scripts/deployCounter.ts</code> with a script that will use the interface class we have just written:</p>
<pre><code class="ts language-ts">import * as fs from "fs";
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, Cell, WalletContractV4 } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class from step 7

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // prepare Counter's initial code and data cells for deployment
  const counterCode = Cell.fromBoc(fs.readFileSync("build/counter.cell"))[0]; // compilation output from step 6
  const initialCounterValue = Date.now(); // to avoid collisions use current number of milliseconds since epoch as initial value
  const counter = Counter.createForDeploy(counterCode, initialCounterValue);

  // exit if contract is already deployed
  console.log("contract address:", counter.address.toString());
  if (await client.isContractDeployed(counter.address)) {
    return console.log("Counter already deployed");
  }

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // send the deploy transaction
  const counterContract = client.open(counter);
  await counterContract.sendDeploy(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for deploy transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("deploy transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre>
<p>Before running this code, make sure you have enough TON in your wallet for the gas payments and the TON sent to the contract during the deploy.</p>
<p>Another thing to watch out for is collisions between different users of this tutorial. As you recall, if the code and initial data of two contracts are identical, they will have the same address. If all followers of this tutorial would choose initial counter value of <code>1</code> - then all of them would collide and only the first would actually deploy the contract. To make sure this doesn't happen, the code above initializes the counter value to the current number of milliseconds since the epoch (something like 1674253934361). This guarantees that your contract for deployment is unique.</p>
<p>To deploy a contract using our script, run the following command in the terminal and follow the on-screen instructions:</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>If you have network connectivity issues and get errors like backend nodes unhealthy or timeouts, please join the <a href="https://t.me/TONAccessSupport">Telegram support chat</a> for TON access to get assistance. A common mistake is trying to use a wallet contract that isn't deployed or funded. This can happen if you're setting the wrong wallet version. As explained in the previous tutorial, check your wallet address in an <a href="https://testnet.tonscan.org">explorer</a> and if your wallet has a different version from "wallet v4 r2" you will need to modify slightly the code above. Let's say for example that your version is "wallet v3 r2", then replace <code>WalletContractV4</code> with <code>WalletContractV3R2</code>.</p>
<p>The script will print the newly deployed contract address - mine is <code>EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb</code>. You can open your address in an <a href="https://testnet.tonscan.org">explorer</a> to verify that the deploy went smoothly. This is what it should look like:</p>
<p><img src="https://i.imgur.com/SLR7nmE.png" width=600 /><br></p>
<p>Write down your deployed contract address. We're going to use it in the next step.</p>
<h2 id="step9callagetteronthedeployedcontract">Step 9: Call a getter on the deployed contract</h2>
<p>There are two ways to interact with a smart contract - calling a getter to read data from it or sending a message that can potentially change its state (write). We should support these interactions in the contract interface class that we created in step 7.</p>
<p>Anyone who wants to access the contract from TypeScript would simply use this interface class. This is excellent for separation of responsibilities within your team. The developer of the contract can provide this class to the developer of the client to abstract away implementation details such as how messages should be encoded in the binary level. Let's start with the getter.</p>
<h3 id="interfaceclass-1">Interface class</h3>
<p>Add the following to <code>wrappers/Counter.ts</code>:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async getCounter(provider: ContractProvider) {
    const { stack } = await provider.get("counter", []);
    return stack.readBigNumber();
  }

// }
</code></pre>
<p>Notice that methods in the interface class that call getters must start with the word <code>get</code>. This prefix is a requirement of the <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a> TypeScript library. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step9.ts">this</a>.</p>
<h3 id="executingthecall">Executing the call</h3>
<p>Calling a getter is free and does not cost gas. The reason is that this call is read-only, so it does not require consensus by the validators and is not stored in a block on-chain for all eternity like transaction are.</p>
<p>Let's create a new script called <code>getCounter.ts</code> in the <code>scripts</code> folder and use our shiny interface class to make the call. We're going to emulate a different developer interacting with our contract and since the contract is already deployed, they are likely to access it by address. Be sure to replace my deployed contract address with yours in the code below:</p>
<pre><code class="ts language-ts">import { getHttpEndpoint } from "@orbs-network/ton-access";
import { TonClient, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // call the getter on chain
  const counterValue = await counterContract.getCounter();
  console.log("value:", counterValue.toString());
}
</code></pre>
<p>As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "getCounter" from the list of available scripts.</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>Make a note of the current counter value. After we send the increment message in the next step we would like to confirm that this value indeed increases by 1.</p>
<p>Another interesting thing to remember is that getters are only accessible off-chain, for example from a JavaScript client making a call through an RPC service provider. In particular, this means that contracts cannot call getters on other contracts.</p>
<h2 id="step10sendatransactiontothedeployedcontract">Step 10: Send a transaction to the deployed contract</h2>
<p>Unlike getters that are read-only, messages can write and change contract state in storage. In our contract implementation we handled messages in <code>recv_internal()</code> and assigned op #1 = <em>increment</em>. Sending messages costs gas and requires payment in TON coin. The reason is that this operation is not read-only, so it requires waiting for consensus by the validators and is stored as a transaction in a block on-chain for all eternity. We will send less TON coin this time since this action is much cheaper than the deployment.</p>
<h3 id="interfaceclass-2">Interface class</h3>
<p>Add the following to <code>wrappers/Counter.ts</code>:</p>
<pre><code class="ts language-ts">// export default class Counter implements Contract {

  async sendIncrement(provider: ContractProvider, via: Sender) {
    const messageBody = beginCell()
      .storeUint(1, 32) // op (op #1 = increment)
      .storeUint(0, 64) // query id
      .endCell();
    await provider.internal(via, {
      value: "0.002", // send 0.002 TON for gas
      body: messageBody
    });
  }

// }
</code></pre>
<p>As you recall, the increment message is an <a href="https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages">internal message</a> that is encoded by convention with a 32 bit unsigned int in the beginning to describe the op and a 64 bit unsigned int after to describe the query id. The query id is relevant for messages that expect a response message to be sent back (the request and the response share the same query id).</p>
<p>Notice that methods in the interface class that send messages must start with the word <code>send</code>, another prefix requirement of the <a href="https://www.npmjs.com/package/@ton/ton">@ton/ton</a> library. The resulting source file should look like <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test/counter.step10.ts">this</a>.</p>
<h3 id="executingthesend">Executing the send</h3>
<p>The messages can be sent from any TON wallet, not necessarily the deployer wallet. Create a new script <code>sendIncrement.ts</code> in the <code>scripts</code> folder and use your wallet to fund the send:</p>
<pre><code class="ts language-ts">import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, WalletContractV4, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // send the increment transaction
  await counterContract.sendIncrement(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre>
<p>As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "sendIncrement" from the list of available scripts.</p>
<pre><code class="console language-console">npx blueprint run
</code></pre>
<p>Notice that the message will take a few seconds to be processed by validators and will only change contract state after it has been processed. The normal wait time is a block or two, since validators need to produce a new block that contains our sent transaction. The op that was sent above is #1 = <em>increment</em>, which means that after processing, the counter value will increase by 1. Verify this by re-running the script from step 9 to print the new counter value.</p>
<p>Messages can be sent to our contract by other contracts. This means a different contract can increment our counter. This allows the TON ecosystem to create composable apps and protocols that build on top of each other and interact in unforeseen ways.</p>
<h2 id="reward">Reward</h2>
<p>Congratulations on successfully completing this tutorial! Before we conclude, let's take a quick look at the exciting reward awaiting you from the <a target="_blank" href="https://getgems.io/collection/EQA4RIS6uxt1GZkTTr19Wy423NZtcG0pRy29lg55X-qYq-Tf">"TON Masters"</a> collection:</p>
<video style="border-radius: 10pt; margin: 25pt auto; display: block;" width="40%" autoplay loop muted playsinline>
  <source src="https://ton-devrel.s3.eu-central-1.amazonaws.com/tal-tutorials/2-smart/video.mp4" type="video/mp4">
</video>
<p>Ready to claim your reward? Simply scan the QR code below or click <a href="ton://transfer/EQCZ52LU4PsK71IVjn4Ur599R4ZdsnT9ToAEqysot628BEdo?bin=te6cckEBAQEABgAACACZ_fWVyQMr&amount=50000000">here</a>:
<img src="https://i.imgur.com/GEuOQjr.png" width=300 alt="QR-code" style="display: block; margin-left: auto; margin-right: auto; width: 50%;"/></p>
<h2 id="conclusion">Conclusion</h2>
<p>For your convenience, all the code in this tutorial is available in executable form <a href="https://github.com/ton-community/tutorials/blob/main/02-contract/test">here</a>.</p>
<p>In this tutorial we handled the build and deploy processes manually, mostly so we can understand what happens under the hood. When creating a new contract project, you can have these processes managed automatically by an awesome dev tool called <a href="https://github.com/ton-community/blueprint">Blueprint</a>. To create a new contract project with Blueprint, run in terminal and follow the on-screen instructions:</p>
<pre><code class="console language-console">npm create ton@latest
</code></pre>
<p>If you found a mistake in this tutorial, please <a href="https://github.com/ton-community/tutorials/pulls">submit a PR</a> and help us fix it. This tutorial platform is fully open source and available on <a href="https://github.com/ton-community/tutorials">https://github.com/ton-community/tutorials</a>.</p>
<p>Happy coding!</p>
         </div>
        
      </div>
    </div>
  </body>
</html>